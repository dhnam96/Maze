#CS0330 Maze

This project creates a 2 by 2 array to represent a maze in the generator. By first, initializing the maze, a num_row by num_col blank maze is created by user input. Then, using the recursive drunken walk algorithm, from the left top most room of the maze, walls and connections are set so that all rooms are visitable. The maze is created differently by using random directions for the drunken walk algorithm. When the connections are all set, the maze is translated to a hexadecimal representation and printed out to a file. This file, is then read by the solver to replicate the maze in the solver. Then, the solver produces a Depth First Search solution. The solution is then printed out with the word PRUNE. If a macro of FULL is specified, the solution will show all of the paths, including the backtrace, for the algorithm to get to the solution. 

##Getting Started

First, I started out by filling in the maze_room struct in the header file of common. Then, I filled in the functions in the common. To ensure that the function get_neighbors does not produce any segmentation faults, I included the is_in_range method to check the neighbors before returning. In the generator, I first started by initializing the maze and making a blank maze of dimensions num_rows by num_cols. Then, I used the druken walk algorithm to create connections (walls and opening) so that each maze is visitable. The room of each maze holds the value of its location, its four connections, and whether it has been visited. Once the drunken algorithm is recursed until all room of the maze has been visited, the maze's connection is converted to a hexadecimal representation. If there is a wall, it is represented by a 1. If there is a opening, it is represented by a 0. By using an array of integers, I've located the north connection to the first element, south connection to the second element, west connection to the third element, and the east connection to the fourth element of the array. 

I used an array to specify the connections since the directions are enums and in that way, it will be easier to access each connection depending on the array. Now, this binary representation is converted to a decimal representation in encode_room by multiplying 8 to the the fourth element, 4 to the third element, 2 to the second element, and 1 to the first element. Each room of the maze is translated to a decimal number and printed out to a file as a hexadecimal number. In the file, each number represents the connections of the room. 

In the solver file, the maze is re-initialized and using the fscan function, the file generated by the generator is translated back to a binary number and subsequently, the connections are stored in the maze's maze_room structure. Here, using a depth first search algorithm, a solution path is found. When the macro FULL is mentioned, the solution of every step, including the back trace, is printed out to a file. If the macro is unspecified, the shortest solution found by DFS will be printed out. The solver should return 0 if no error has been raised.

###Error Checking

In order to check for errors, I created several if statements that returns 1 in case an illegal argument is put in. Since the main() of a function only receives input from the users, it is necessary just to check if the inputs are correct in the main(). I also made sure that the maze file created by the generator has been translated correctly. 

In the generator, I made sure the drunken walk algorithm works recursively by checking if all of the room has been visited and by printing out values of the connections of the room and its location.

###Organization

Each program is organized as specified on the handout. I tried my best to make the code concise. I considered creating a helper function for the drunken walk algorithm but thought the functionality of the helper function would be confusing for the readers. So, instead, I just made a recursive drunken walk algorithm following the pseudo code. The three helper functions created in the generator are print_results, which prints the hexadecimal representation of the maze to the file, swap, which swaps two elements, and initial_board, which initializes a blank board. 

I made sure to store important values to the maze_room structure to keep track of and access or mutate it when needed.

The solver file also has one helper function maze_creater, which uses the input maze file to encode the room. The function, create_room_connection is called on every room. The hexadecimal representation was translated by using the fscan function. In the DFS function of the solver, I had two choices. I could either print both of my possible solutions (depending on the macro) or just print one of the two and print the other in the main(). I decided to do the latter because the code was better organized and also shorter. This choice was made to create simplicity and readability in the code. 

###Difficulties 

The only difficult portion of the project was to make sure there were no segmentation faults and that the pointer values are changed correctly. This project definitely helped me understand the pointers of C. Otherwise everythign was very straight forward.

###Notes on my code

In the DFS of my code, I don't use any directions since directions are already an enum and knowing that there are four directions, I just used a for loop that looped around four times and the direction enum to point out the direction. 

I only decided to print the macro in the DFS function because the printing does not use any loops. 

I placed the PRUNED solutions in the main portion because of readability and code organization for clarity and shortness. 

